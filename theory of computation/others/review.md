#### 1 正则语言与自动机

**NFA 转 DFA**，以下题为例

![png](./review/1.png)

* 状态集：原NFA中，状态集合的所有子集构成的集合。如NFA状态集{1,2,3}，则DFA的状态集{$\O$,{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}

* 起始状态：从NFA的起始状态出发，沿着$\epsilon$箭头能够到达的所有状态，加上起始状态本身。如NFA起始状态为1，沿着$\epsilon$能够到达3，故DFA的起始状态为{1,3}

* 接受状态集：包含NFA所有接受状态集中元素的DFA的状态构成的集合。如NFA的接受状态集为{1}，则DFA的接受状态集为{{1},{1,2},{1,3},{1,2,30}}

* 转移函数：书上讲的很乱，这里用 $\epsilon$-closure 闭包来求一个标准解。

  - 首先构造NFA的状态转移表：

    |      | a      | b    |
    | ---- | ------ | ---- |
    | 1    | $\O$   | {2}  |
    | 2    | {2, 3} | {3}  |
    | 3    | {1}    | $\O$ |
  
  * 求出NFA各状态 $\epsilon$-closure 闭包，$\epsilon$-closure(q) 表示状态 q 通过 $\epsilon$ 边能够转移到的状态集合
  
    $\epsilon$-closure( 1 ) = {1, 3}
  
    $\epsilon$-closure( 2 ) = {2}
  
    $\epsilon$-closure( 3 ) = {3}
  
  * 对每个状态，求出在所有输入符号下的转移状态，并对这个状态求闭包，其意义为：某个状态在该输入符号下转移到这个闭包对应的状态
  
    （其实只对每个出现过的（可以转移到的）状态求就可以了，像对{1}、{1,2}求就没有必要，为了完整这里补充上了，这里 O 表示 $\O$，e表示$\epsilon$-closure，作用在集合上就是对作用于元素的并集）
  
    * ({1}, a) => O,    e(  O ）= O    *（没用）* 
  
      ({1}, b) => {2},    e(  {2} ）= {2}   *（没用）* 
  
    * ({2}, a) => {2,3},    e(  {2,3} ）= {2,3}
  
      ({2}, b) => {3},    e(  {3} ）= {3}
  
    * ({3}, a) => {1},    e( {1} ) = {1, 3}
  
      ({3}, b) => O,    e( O ) = O
  
    * ({1, 2}, a) => {2, 3},    e( {2, 3} ) = {2, 3}   *（没用）* 
  
      ({1, 2}, b) => {2, 3},    e( {2, 3} ) = {2, 3}   *（没用）* 
  
    * ({1, 3}, a) => {1},    e( {1} ) = {1, 3}
  
      ({1, 3}, b) => {2},    e( {2} ) = {2}
  
    * ({2, 3}, a) => {1, 2, 3},    e(  {1,2,3} ）= {1,2,3}
  
      ({2, 3}, a) => {3},    e(  {3} ）= {3}
  
    * ({1, 2, 3}, a) => {1, 2, 3},    e(  {1,2,3} ）= {1,2,3}
  
      ({1, 2, 3}, b) => {2, 3},    e(  {2,3} ）= {2,3}
  
    * (O, a) => O,    e(  O ）= O
  
      (O, b) => O,    e(  O ）= O
  
  * 根据状态转移，我们可以画图
  
    ![png](./review/2.png)
  
    
  
  * 删掉没用的（不会转移到的）状态
  
    ![png](./review/3.png)



**DFA 转 RE**

广义非确定型有穷自动机（GNFA）

加入新的起始状态 s ，用空边指向原来的起始状态；新的接受状态 a，将所有原来的接受状态都用空边指向 a。

删点t，若某个状态 p 经过该状态t到达另一个状态 q ，则加入一条p到q的转移，中间是在t上经过的正则表达式组合；若原来已经存在这个转移，则用∪合并。（刷题找感觉）

(a|bba)* ba(aa* b)* a|e



**RE 转 NFA**

有一点点像汤普森算法（Project 1）

（刷题找感觉）





**泵引理**





